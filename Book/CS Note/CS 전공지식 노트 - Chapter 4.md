# 데이터베이스

## 데이터베이스의 기본
- 데이터베이스
  - 일정한 규칙 혹은 규약을 통해 구조화되어 저장되는 데이터의 모음
  - 실시간 접근과 동시 공유 가능
### 엔터티
- 여러 개의 속성을 지닌 명사
  - ex. 회원 → 이름, 아이디, 주소, ...
- 약한 엔터티, 강한 엔터티
### 릴레이션
- 데이터베이스에서 정보를 구분하여 저장하는 기본 단위
- 관계형 데이터베이스에서는 '테이블', NoSQL 데이터베이스에서는 '컬렉션'
### 속성
- 릴레이션에서 관리하는 구체적이며 고유한 이름을 갖는 정보
### 도메인
- 릴레이션에 포함된 각각의 속성들이 가질 수 있는 값의 집합
  - ex. 성별 → {남, 여}
### 필드와 레코드
- 레코드 = 튜플
  - 테이블에 쌓이는 행 단위의 데이터
- 필드 타입 (MySQL 기준)
  - 숫자 타입
    - TINYINT, SMALLINT, MEDIUMINT, INT, BIGINT
  - 날짜 타입
    - DATE, DATETIME, TIMESTAMP
  - 문자 타입
    - CHAR(0~255), VARCHAR(0~65535)
      - 지정된 형태에 따라 저장된 CHAR의 경우 검색에 유리
      - 검색을 별로 하지 않고 유동적인 길이를 가진 데이터는 VARCHAR로 저장하는 것이 좋음
    - TEXT, BLOB
      - 큰 데이터를 저장할 때 사용
      - TEXT는 큰 문자열 저장에 사용됨
        - ex. 게시판 본문 저장
      - BLOB은 이미지, 동영상 등 큰 데이터 저장에 사용됨
        - _그러나_ 보통은 S3를 이용하는 등 서버에 파일을 올리고 파일 경로를 VARCHAR로 저장
    - ENUM, SET
      - 문자열 열거 타입
      - ENUM은 단일 선택, SET은 여러 개의 데이터 선택
      - 공간적으로 이점을 볼 수 있지만 애플리케이션 수정에 따라 정의한 목록을 수정해야 한다는 단점이 있음
### 관계
- 1:1 관계
- 1:N 관계
- N:M 관계
### 키
- 유일성
  - 중복되는 값이 없음
- 최소성
  - 필드를 조합하지 않고 최소 필드만 써서 키를 형성할 수 있음
- 기본키(PK)
  - 유일성과 최소성을 만족
  - 자연키 또는 인조키 중에 골라서 설정
    - 자연키
      - 중복된 값들을 제외하며 중복되지 않는 것을 '자연스레' 뽑다가 나오는 키
        - ex. 주민등록번호
      - 언젠가는 변하는 속성을 가짐
    - 인조키
      - 인위적으로 생성한 키
      - 자연키와 대조적으로 변하지 않음
      - 보통 기본키는 인조키로 설정함
- 외래키(FK)
  - 다른 테이블의 기본키를 그대로 참조
  - 개체와의 관계를 식별하는 데 사용
- 후보키
  - 기본키가 될 수 있는 후보들
  - 유일성과 최소성을 동시에 만족
- 대체키
  - 후보키가 두 개 이상일 경우 어느 하나를 기본키로 지정하고 남은 후보키들
- 슈퍼키
  - 각 레코드를 유일하게 식별할 수 있는 유일성을 갖춘 키

## ERD와 정규화 과정
- ERD
  - 데이터베이스를 구축할 때 가장 기초적인 뼈대 역할
  - 릴레이션 간의 관계들을 정의
### ERD의 중요성
- ERD는 시스템의 요구 사항을 기반으로 작성되며 이 ERD를 기반으로 데이터베이스 구축
- 관계형 구조로 표현할 수 있는 데이터를 구성하는 데 유용할 수 있지만 비정형 데이터를 충분히 표현할 수 없다는 단점이 있음
### 정규화 과정
- 기본 정규형
  - 제1정규형
    - 릴레이션의 모든 도메인이 더 이상 분해될 수 없는 원자 값만으로 구성되어야 함
    - 릴레이션의 속성 값 중에서 한 개의 기본키에 대해 두 개 이상의 값을 가지는 반복 집합이 있어서는 안 됨 (있다면 제거해야 함)
  - 제2정규형
    - 릴레이션이 제1정규형이며 부분 함수의 종속성을 제거한 형태
      - 부분 함수의 종속성 제거
        - 기본키가 아닌 모든 속성이 기본키에 완전 함수 종속적인 것
  - 제3정규형
    - 제2정규형이고 기본키가 아닌 모든 속성이 이행적 함수 종속을 만족하지 않는 상태
      - 이행적 함수 종속
        - A → B와 B → C가 존재하면 논리적으로 A → C 성립, 이 때 집합 C가 집합 A에 이행적으로 함수 종속이 됨
  - 보이스/코드 정규형
    - 제3정규형이고 결정자가 후보키가 아닌 함수 종속 관계를 제거하여 릴레이션의 함수 종속 관계에서 모든 결정자가 후보키인 상태
      - 결정자
        - 함수 종속 관계에서 특정 종속자를 결정짓는 요소, X → Y일 때 X는 결정자, Y는 종속자
- 고급 정규형
  - 제4정규형
  - 제5정규형
- 정규형 과정을 거쳐 테이블을 나눈다고 해서 성능이 100% 좋아지는 것은 아님 (성능이 좋아질 수도 나빠질 수도 있음)
  - 어떠한 쿼리는 조인을 해야 하는 경우도 발생해서 오히려 느려질 수 있기 때문
  - 서비스에 따라 정규화 또는 비정화 과정을 진행해야 함

## 트랜잭션과 무결성
### 트랜잭션
- 데이터베이스에서 하나의 논리적 기능을 수행하기 위한 작업의 단위
- 여러 개의 쿼리들을 하나로 묶는 단위
- ACID (특징)
  - 원자성(Atomicity)
    - all or nothing
    - 트랜잭션과 관련된 일이 모두 수행되었거나 되지 않았거나를 보장
    - 커밋과 롤백
      - 데이터의 무결성 보장
      - 작업을 그룹화
    - 트랜잭션 전파
      - 여러 트랜잭션 관련 메서드의호출을 하나의 트랜잭션에 묶이도록 하는 것
  - 일관성(Consistency)
    - '허용된 방식'으로만 데이터를 변경해야 하는 것
    - 데이터베이스에 기록된 모든 데이터는 여러 가지 조건, 규칙에 따라 유효함을 가져야 함
  - 독립성 = 격리성(Isolation)
    - 트랜잭션 수행 시 서로 끼어들지 못하는 것
    - 여러 개의 격리 수준으로 나뉘어 격리성을 보장
      - 격리수준(발생 현상) → SERIALIZABLE(0), REPEATABLE_READ(1), READ_COMMITTED(2), READ_UNCOMMITTED(3)
        - 오른쪽으로 갈수록 동시성은 강해지지만 격리성은 약해지고, 왼쪽으로 갈수록 동시성은 약해지고 격리성은 강해짐
        - 오른쪽으로 하나씩 이동할 때 다음 현상이 하나씩 더해짐 (팬텀 리드, 반복 가능하지 않은 조회, 더티 리드)
    - 격리 수준에 따라 발생하는 현상
      - 팬텀 리드(phantom read)
        - 한 트랜잭션 내에서 동일한 쿼리를 보냈을 때 조회 결과가 다른 경우
      - 반복 가능하지 않은 조회(non-repeatable read)
        - 한 트랜잭션 내의 같은 행에 두 번 이상 조회가 발생했는데, 그 값이 다른 경우
      - 더티 리드(dirty read)
        - 한 트랜잭션이 실행 중일 때 다른 트랜잭션에 의해 수정되었지만 아직 '커밋되지 않은' 행의 데이터를 읽을 수 있는 경우
    - 격리 수준
      - SERIALIZABLE
        - 트랜잭션을 순차적으로 진행시킴
        - 교착 상태가 일어날 확률이 많고 가장 성능이 떨어짐
      - REPEATABLE_READ
        - 하나의 트랜잭션이 수정한 행을 다른 트랜잭션이 수정할 수 없도록 막지만 새로운 행을 추가하는 것은 막지 않음
      - READ_COMMITTED
        - 가장 많이 사용되는 격리 수준 (MySQL8.0, PostgreSQL, SQL Server, 오라클에서 기본값으로 설정)
        - 트랜잭션이 커밋하지 않은 정보는 읽을 수 없음 (커밋 완료된 데이터에 대해서만 조회를 허용)
        - 어떤 트랜잭션이 접근한 행을 다른 트랜잭션이 수정할 수 있음
      - READ_UNCOMMITTED
        - 가장 낮은 격리 수준
        - 하나의 트랜잭션이 커밋되기 전에 다른 트랜잭션에 노출되는 문제가 있지만 가장 빠름
  - 지속성(Durability)
    - 성공적으로 수행된 트랜잭션은 영원히 반영되어야 함
    - 데이터베이스에 시스템 장애가 발생해도 원래 상태로 복구하는 회복 기능이 있어야 함을 뜻함
    - 데이터베이스는 이를 위해 체크섬, 저널링, 롤백 등의 기능을 제공
      - 저널링
        - 파일 시스템 또는 데이터베이스 시스템의 변경 사항을 반영하기 전에 로깅하는 것
        - 트랜잭션 등 변경 사항에 대해 로그를 남기는 것
### 무결성
- 데이터의 정확성, 일관성, 유효성을 유지하는 것
- 무결성의 종류
  - 개체 무결성
  - 참조 무결성
  - 고유 무결성
  - NULL 무결성

## 데이터베이스의 종류
### 관계형 데이터베이스
- 행과 열을 가지는 표 형식 데이터를 저장하는 형태의 데이터베이스
- SQL 언어를 써서 조작
- ex. MySQL, PostgreSQL, 오라클, SQL Server, MSSQL 등
### NoSQL 데이터베이스
- Not only SQL이라는 슬로건에서 생겨난 데이터베이스
- SQL을 사용하지 않는 데이터베이스
- ex. MongoDB, Redis 등

## 인덱스
### 인덱스의 필요성
- 데이터를 빠르게 찾을 수 있는 하나의 장치
### B-트리
- 인덱스는 보통 B-트리라는 자료 구조로 이루어져 있음
- B-트리는 루트 노드, 리프 노드, (루트와 리프 사이에 있는) 브랜치 노드로 나뉨
- 인덱스가 효율적인 이유는 효율적인 단계를 거쳐 모든 요소에 접근할 수 있는 균형 잡힌 트리 구조와 트리 깊이의 대수확장성 때문
  - 대수확장성
    - 트리 깊이가 리프 노드 수에 비해 매우 느리게 성장하는 것을 의미
    - 기본적으로 인덱스가 한 깊이씩 증가할 때마다 최대 인덱스 항목의 수는 4배씩 증가
### 인덱스 만드는 방법
- 인덱스를 만드는 방법은 데이터베이스마다 다름
- ex. MySQL
  - 클러스터형 인덱스, 세컨더리 인덱스
### 인덱스 최적화 기법
- 인덱스 최적화 기법은 데이터베이스마다 조금씩 다르지만 기본적인 골조는 똑같음
- 아래 설명은 MongoDB 기반이지만 다른 데이터베이스에 웬만큼 적용 가능
  1. 인덱스는 비용이다
     - 인덱스는 두 번 탐색하도록 강요함
     - 컬렉션이 수정되었을 때 인덱스도 수정되어야 함
  2. 항상 테스팅하라
     - 인덱스 최적화 기법은 서비스 특징에 따라 달라짐
       - 서비스에서 사용하는 객체의 깊이, 테이블의 양 등이 다르기 때문
       - 그러므로 항상 테스팅하는 것이 중요함
  3. 복합 인덱스는 같음, 정렬, 다중 값, 카디널리티 순이다
     - 여러 필드를 기반으로 복합 인덱스를 생성할 때는 순서가 있고 생성 순서에 따라 성능이 달라짐

## 조인의 종류
- 조인
  - 하나의 테이블이 아닌 두 개 이상의 테이블을 묶어서 하나의 결과물을 만드는 것
- 여러 테이블을 조인하는 작업이 많을 경우 MongoDB보다는 관계형 데이터베이스를 써야 함
### 내부 조인
```sql
SELECT * FROM TableA A INNER JOIN TableB B ON A.key = B.key
```
### 왼쪽 조인
```sql
SELECT * FROM TableA A LEFT JOIN TableB B ON A.key = B.key
```
### 오른쪽 조인
```sql
SELECT * FROM TableA A RIGHT JOIN TableB B ON A.key = B.key
```
### 합집합 조인 (완전 외부 조인)
```sql
SELECT * FROM TableA A FULL OUTER JOIN TableB B ON A.key = B.key
```

## 조인의 원리
### 중첩 루프 조인 (NLJ, Nested Loop Join)
- 중첩 for문과 같은 원리
- 랜덤 접근에 대한 비용이 많이 증가하므로 대용량 테이블에서는 사용하지 않음
### 정렬 병합 조인
- 각각의 테이블을 조인할 필드 기준으로 정렬하고 정렬이 끝난 이후에 조인 작업을 수행
- 조인할 때 쓸 적절한 인덱스가 없고 대용량의 테이블들을 조인하고 조인 조건으로 <, > 등 범위 비교 연산자가 있을 때 씀
### 해시 조인
- 해시 테이블을 기반으로 조인하는 방법
- 두 개의 테이블을 조인한다고 했을 때 하나의 테이블이 메모리에 온전히 들어간다면 보통 중첩 루프 조인보다 더 효율적
- 동등(=) 조건에서만 사용할 수 있음
- MySQL의 해시 조인 단계
  - 빌드 단계
    - 입력 테이블 중 하나를 기반으로 메모리 내 해시 테이블을 빌드하는 단계
      - 둘 중 바이트가 더 작은 테이블을 기반으로 해서 테이블을 빌드
      - 조인에 사용되는 필드가 해시 테이블의 키로 사용됨
  - 프로브 단계
    - 레코드 읽기를 시작하며, 조건에 일치하는 레코드를 찾아서 결괏값으로 반환