# 애그리거트

## 애그리거트
- 상위 수준에서 모델을 정리하면 도메인 모델의 복잡한 관계를 이해해는 데 도움이 됨
- 개별 객체 수준에서 모델을 바라보면 상위 수준에서 관계를 파악하기 어려움
- 주요 도메인 요소 간의 관계를 파악하기 어렵다는 것은 코드를 변경하고 확장하는 것이 어려워진다는 것을 의미
- 복잡한 도메인을 이해하고 관리하기 쉬운 단위로 만들려면 상위 수준에서 모델을 조망할 수 있는 방법이 필요 → 애그리거트
- 애그리거트에 속한 객체는 유사하거나 동일한 라이프 사이클을 가짐
- 애그리거트는 독립된 객체 군 → 자기 자신을 관리할 뿐 다른 애그리거트 관리 X
  - 경계를 설정할 떄 기본이 되는 것은 도메인 규칙과 요구사항

## 애그리거트 루트와 역할
- 애그리거트는 여러 객체로 구성되기 때문에 한 객체만 상태가 정상이면 안 됨
- 애그리거트에 속한 모든 객체가 일관된 상태를 유지하려면 애그리거트 전체를 관리할 주체가 필요
  - 이 책임을 지는 것이 __애그리커트의 루트__ 엔티티
    - 애그리거트에 속한 객체는 애그리거트 루트 엔티티에 직접 또는 간접적으로 속하게 됨
- 도메인 규칙과 일관성
  - 애그리거트 루트의 핵심 역할 → 애그리거트의 일관성이 깨지지 않도록 하는 것
    - 이를 위해 애그리거트 루트는 애그리거트가 제공해야 할 도메인 기능을 구현
      - 도메인 모델에 대해 다음 두 가지를 습관적으로 적용해야 함
        - _단순히 필드를 변경하는 set 메스드를 public 범위로 만들지 않기_
        - _밸류 타입은 불변으로 구현하기_
  - 애그리거트 외부에서 애그리거트에 속한 객체를 직접 변경하면 안 됨
    - 애그리거트 루트가 강제하는 규칙을 적용할 수 없어 모델의 일관성을 깨는 원인이 됨
- 애그리거트 루트의 기능 구현
  - 애그리거트 루트는 애그리거트 내부의 다른 객체를 조합해서 기능을 완성함
  - 애그리거트 루트가 구성요소의 상태만 참조하는 것은 아님 → 기능 실행을 위임하기도 함
- 트랜잭션 범위
  - 트랜잭션 범위는 작을수록 좋음
    - 트랜잭션 충돌을 막기 위해 잠그는 대상(테이블)이 많아지면 그만큼 동시에 처리할 수 있는 트랜잭션 개수가 줄어듦 → 전체적인 성능(처리량) 저하
  - 한 트랜잭션에서는 한 개의 애그리거트만 수정해야 함 (권장)
    - 애그리거트에서 다른 애그리거트를 변경하지 않는다는 것을 의미
    - 부득이하게 한 트랜잭션으로 두 개 이상의 애그리거트를 수정해야 하는 경우
      - 애그리거트에서 다른 애그리거트를 직접 수정하지 말고 응용 서비스에서 두 애그리거트를 수정하도록 구현함
    - 도메인 이벤트를 사용하면 한 트랜잭션에서 한 개의 애그리거트를 수정하면서도 동기나 비동기로 다른 애그리거트의 상태를 변경하는 코드를 작성할 수 있음
  - 다음의 경우 한 트랜잭션에서 두 개 이상의 애그리거트 변경을 고려할 수 있음
    - 팀 표준
    - 기술 제약
    - UI 구현의 편리

## 애그리거트와 리포지터리
- 애그리거트는 개념상 완전한 한 개의 도메인 모델을 표현하므로 객체의 영속성을 처리하는 리포지터리는 애그리거트 단위로 존재
- 리포지터리에 애그리거트를 저장하면 애그리거트 전체를 영속화해야 함 (← 루트 + 모든 구성요소에 매핑된 테이블)
- 애그리거트를 구하는 리포지터리 메서드는 완전한 애그리거트를 제공해야 함

## ID를 이용한 애그리거트 참조
- (한 객체가 다른 객체를 참조하는 것처럼) 애그리거트도 다른 애그리거트를 참조함
  - 애그리거트 관리 주체는 애그리거트 루트이므로 애그리거트에서 다른 애그리거트를 참조한다는 것은 다른 애그리거트 루트를 참조한다는 것
  - 필드를 통해 쉽게 구현할 수 있지만 다음 문제를 야기할 수 있음
    - 편한 탐색 오용 / 성능에 대한 고민 / 확장 어려움
    - 위 문제를 완화할 때 사용할 수 있는 것이 ID를 이용해서 다른 애그리거트를 참조하는 것
- ID 참조를 사용하면 모든 객체가 참조로 연결되지 않고 한 애그리거트에 속한 객체들만 참조로 연결됨
  - 복합도를 낮춤
  - 한 애그리거트에서 다른 애그리거트를 수정하는 문제를 근원적으로 방지
  - 애그리거트별로 다른 구현 기술을 사용하는 것이 가능해짐
- ID를 이용한 참조와 조회 성능
  - ID를 이용한 애그리거트 참조는 지연 로딩과 같은 효과를 만듦
    - 대표적인 문제로 N+1 조회 문제가 발생
      - 더 많은 쿼리를 실행하기 때문에 전체 조회 속도가 느려지는 원인이 됨
        - 이 문제가 발생하지 않도록 하려면 조인을 사용해야 함
        - 조인을 사용하는 가장 쉬운 방법 → ID 참조 방식을 객체 참조 방식으로 바꾸고 즉시 로딩을 사용하도록 매핑 설정 변경 (← 되돌아가게 됨)
    - ID 참조 방식에서는 N+1 조회 문제를 발생하지 않도록 조회 전용 쿼리를 사용함
      - 데이터 조회를 위한 별도 DAO를 만들고 DAO 조회 메서드에서 조인을 이용해 한 번의 쿼리로 필요한 데이터 로딩
      - 애그리거트마다 서로 다른 저장소를 사용하면 한 번의 쿼리로 관련 애그리거트를 조회할 수 없음
        - 이때는 조회 성능을 높이기 위해 캐시를 적용하거나 조회 전용 저장소를 따로 구성

### 애그리거트 간 집합 연관
- 애그리거트 간 1-N과 M-N 연관
  - 컬렉션을 이용한 연관
- 개념적으로 애그리거트 간에 1-N 연관이 있어도 성능 문제가 있어 실제 구현에는 반영하지 않음 (N-1로 연관 지어 사용)

### 애그리거트를 팩토리로 사용하기
- 애그리거트가 갖고 있는 데이터를 이용해서 다른 애그리거트를 생성해야 한다면 애그리거트에 팩토리 메서드를 구현하는 것을 고려해 볼 것