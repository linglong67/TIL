# 리포지터리와 모델 구현
- JPA를 이용한 리포지터리 구현
- 엔티티와 밸류 매핑
- 밸류 컬렉션 매핑
- 애그리거트 로딩 전략과 영속성 전파
- 식별자 생성 기능

## JPA를 이용한 리포지터리 구현
- 리포지터리 인터페이스는 애그리거트 루트를 기준으로 작성
- 애그리거트를 조회하는 기능의 이름을 지을 때, 널리 사용되는 규칙 → findBy프로퍼티이름(프로퍼티 값)

## 스프링 데이터 JPA를 이용한 리포지터리 구현
- 스프링과 JPA를 함께 적용할 때는 스프링 데이터 JPA를 사용
- 스프링 데이터 JPA는 지정한 규칙에 맞게 리포지터리 인터페이스를 정의하면 리포지터리를 구현한 객체를 알아서 만들어 스프링 빈으로 등록
- 스프링 데이터 JPA를 사용하려면 지정한 규칙에 맞게 메서드를 작성해야 함

## 매핑 구현
- 엔티티와 밸류 기본 매핑 구현
  - 애그리거트 루트는 엔티티이므로 @Entity로 매핑 설정 (기본 규칙)
  - 한 테이블에 엔티티와 밸류 데이터가 같이 있을 경우
    - 밸류는 @Embeddable로 매핑 설정
    - 밸류 타입 프로퍼티는 @Embedded로 매핑 설정
- 기본 생성자
  - JPA에서 @Entity와 @Embeddable로 클래스를 매핑하려면 기본 생성자를 제공해야 함
    - DB에서 데이터를 읽어와 매핑된 객체를 생성할 때 기본 생성자를 사용해서 객체를 생성하기 때문
    - 기본 생성자는 JPA 프로바이더가 객체를 생성할 때만 사용
    - 기본 생성자를 다른 코드에서 사용하면 값이 없는 온전하지 못한 객체를 만들게 되므로 protected로 선언
- 필드 접근 방식 사용
  - 객체가 제공할 기능 중심으로 엔티티를 구현하게끔 유도하려면 JPA 매핑 처리를 프로퍼티 방식이 아닌 필드 방식으로 선택해서 불필요한 get/set 메서드를 구현하지 말아야 함
- AttributeConverter를 이용한 밸류 매핑 처리
  - 두 개 이상의 프로퍼티를 가진 밸류 타입을 한 개 컬럼에 매핑할 때 AttributeConverter를 사용할 수 있음
- 밸류 컬렉션: 별도 테이블 매핑
  - @ElementCollection과 @CollectionTable을 함께 사용
- 밸류 컬렉션: 한 개 컬럼 매핑
  - AttributeConverter를 사용하면 밸류 컬렉션을 한 개 컬럼에 쉽게 매핑할 수 있음
    - ex. 도메인 모델 → 이메일 주소 목록을 Set으로 보관 / DB → 한 개 컬럼에 콤마로 구분해서 저장
  - 단, AttributeConverter를 사용하려면 밸류 컬렉션을 표현하는 새로운 밸류 타입을 추가해야 함
- 밸류를 이용한 ID 매핑
  - 밸류 타입을 식별자로 매핑하면 @Id 대신 @EmbeddedId 애너테이션을 사용
  - JPA에서 식별자 타입은 Serializable 타입이어야 하므로 식별자로 사용할 밸류 타입은 Serializable 인터페이스를 상속받아야 함
    - ex. _public class OrderNo implements Serializable { ... }_
  - 밸류 타입으로 식별자를 구현할 때 얻을 수 있는 장점 → 식별자에 기능을 추가할 수 있음
  - JPA는 내부적으로 엔티티를 비교할 목적으로 equals() 메서드와 hashcode() 값을 사용하므로 식별자로 사용할 밸류 타입은 이 두 메시더를 알맞게 구현해야 함
- 별도 테이블에 저장하는 밸류 매핑
  - 애그리거트에서 루트 엔티티를 뺀 나머지 구성요소는 대부분 밸류
    - 루트 엔티티 외에 또 다른 엔티티가 있다면 진짜 엔티티인지 의심해 봐야 함
    - 단지 별도 테이블에 저장한다고 해서 엔티티인 것은 아님
    - 밸류가 아니라 엔티티가 확실하다면 해당 엔티티가 다른 애그리거트는 아닌지 확인해야 함
      - 특히 자신만의 독자적인 라이프 사이클을 갖는다면 구분되는 애그리거트일 가능성이 높음
        - ex. Product - Review
  - 밸류를 매핑할 테이블을 지정하기 위해 @SecondaryTable과 @AttributeOverride을 사용
- 밸류 컬렉션을 @Entity로 매핑하기
  - 개념적으로 밸류인데 구현 기술의 한계나 팀 표준 때문에 @Entity를 사용해야 할 때도 있음
  - JPA는 @Embeddable 타입의 클래스 상속 매핑을 지원하지 않음
  - 상속 구조를 갖는 밸류 타입을 사용하려면 @Embeddable 대신 @Entity를 이용해서 상속 매핑으로 처리해야 함
    - 밸류 타입을 @Entity로 매핑하므로 식별자 매핑을 위한 필드도 추가해야 함
    - 구현 클래스를 구분하기 위한 타입 식별(discriminator) 칼럼을 추가해야 함
- ID 참조와 조인 테이블을 이용한 단방향 M-N 매핑
  - ID 참조를 이용한 애그리거트 간 단방향 M-N 연관은 밸류 컬렉션 매핑과 동일한 방식으로 설정
    - 차이점이 있다면 집합의 값에 밸류 대신 연관을 맺는 식별자가 온다는 점

## 애그리거트 로딩 전략
- JPA 매핑을 설정할 때 항상 기억해야 할 점 → 애그리거트에 속한 객체가 모두 모여야 완전한 하나가 된다는 것
- 조회 시점에서 애그리거트를 완전한 상태가 되도록 하려면 애그리거트 루트에서 연관 매핑의 조회 방식을 즉시 로딩(FetchType.EAGER)으로 설정
  - 보통 조회 성능 이슈 때문에 즉시 로딩 방식을 사용하지만 조회되는 데이터 개수가 많아지면 즉시 로딩 방식을 사용할 때 성능 검토 필요
    - ex. 실행 빈도, 트래픽, 지연 로딩 시 실행 속도 등
- 애그리거트는 개념적으로 하나여야 하지만 루트 엔티티를 로링하는 시점에 애그리거트에 속한 객체를 모두 로딩해야 하는 것은 아님
- 애그리거트가 완전해야 하는 이유
  - 상태를 변경하는 기능을 실행할 때 애그리거트 상태가 완전해야 하기 때문
  - 표현 영역에서 애그리거트의 상태 정보를 보여줄 때 필요하기 때문
- 일반적인 애플리케이션은 상태 변경 기능을 실행하는 빈도보다 조회 기능을 실행하는 빈도가 훨씬 높음
  - 상태 변경을 위해 지연 로딩을 사용할 때 발생하는 추가 쿼리로 인한 실행 속도 저하는 보통 문제가 되지 않음
- 애그리거트 내의 모든 연관을 즉시 로딩으로 설정할 필요는 없음

## 애그리거트의 영속성 전파
- 애그리거트가 완전한 상태여야 한다는 것 → 애그리거트 루트를 조회할 때뿐만 아니라 저장하고 삭제할 대도 하나로 처리해야 함을 의미
- @Embeddable 매핑 타입은 함께 저장되고 삭제되므로 cascade 속성을 추가로 설정하지 않아도 됨
- 반면에 애그리거트에 속한 @Entity 타입에 대한 매핑은 cascade 속성을 사용해서 저장과 삭제 시에 함께 처리되도록 설정해야 함

## 식별자 생성 기능
- 식별자는 크게 세 가지 방식 중 하나로 생성
  - 사용자가 직접 생성
  - 도메인 로직으로 생성
  - DB을 이용한 일련번호 사용
- 식별자 생성 규칙이 있다면 엔티티를 생성할 때 식별자를 엔티티가 별도 서비스로 식별자 생성 기능을 분리해야 함
  - 식별자 생성 규칙은 도메인 규칙이므로 도메인 영역에 식별자 생성 기능을 위치시켜야 함
  - 식별자 생성 규칙을 구현하기에 적합한 또 다른 장소는 리포지터리
    - DB 자동 증가 컬럼을 식별자로 사용하면 식별자 매핑에서 @GeneratedValue를 사용

## 도메인 구현과 DIP
- 도메인에서 구현 기술에 대한 의존을 없애려면 구현 클래스를 인프라에 위치시켜야 함
  - 이 구조를 가지면 구현 기술을 변경하더라도 도메인이 받는 영향을 최소화할 수 있음
- DIP를 적용하는 주된 이유는 저수준 구현이 변경되더라도 고수준이 영향을 받지 않도록 하기 위함
  - 하지만 리포지터리와 도메인 모델의 구현 기술은 거의 바뀌지 않음
  - 이렇게 변경이 거의 없는 상황에서 변경을 미리 대비하는 것은 과하다고 생각