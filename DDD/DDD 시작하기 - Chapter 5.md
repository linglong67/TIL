# 스프링 데이터 JPA를 이용한 조회 기능
- 스펙
- JPA 스펙 구현
- 정렬과 페이징
- 동적 인스턴스와 @Subselect

## 시작에 앞서
- CQRS
  - 명령(Command) 모델과 조회(Query) 모델을 분리하는 패턴
  - 명령 모델 → 상태를 변경하는 기능을 구현할 때 사용
  - 조회 모델 → 데이터를 조회하는 기능을 구현할 때 사용
- 도메인 모델은 명령 모델로 주로 사용됨
- 반면에 이 장에서 설명할 정렬, 페이징, 검색 조건 지정과 같은 기능은 조회 기능에 사용됨

## 검색을 위한 스펙
- 검색 조건을 다양하게 조합해야 할 때 사용할 수 있는 것이 스펙(Specification)
- 스펙은 애그리거트가 특정 조건을 충족하는지 검사할 때 사용하는 인터페이스

## 스프링 데이터 JPA를 이용한 스펙 구현
- 스프링 데이터 JPA는 검색 조건을 표현하기 위한 인터페이스인 Specification을 제공
- 스펙 인터페이스는 함수형 인터페이스이므로 람다식을 이용해서 객체 생성 가능 

## 리포지터리/DAO에서 스펙 사용하기
- 스펙을 충족하는 엔티티를 검색하고 싶다면 findAll() 메서드를 사용하면 됨
  - findAll() 메서드는 스펙 인터페이스를 파라미터로 가짐

## 스펙 조합
- 스프링 데이터 JPA가 제공하는 스펙 인터페이스는 스펙을 조합할 수 있는 두 메서드를 제공하고 있음 → and, or
- and()와 or() 메서드는 기본 구현을 가진 디폴트 메서드
- not(), where() 메서드도 제공 (정적 메서드)
  - where() → null을 전달하면 아무 조건도 생성하지 않는 스펙 객체를 리턴하고 null이 아니면 인자로 받은 스펙 객체를 그대로 리턴

## 정렬 지정하기
- 스프링 데이터 JPA는 두 가지 방법을 사용해서 정렬
  - 메서드 이름에 OrderBy를 사용해서 정렬 기준 지정
  - Sort를 인자로 전달
- 메서드 이름에 OrderBy를 사용하는 방법은 간단하지만 정렬 기준 프로퍼티가 두 개 이상이면 메서드 이름이 길어지는 단점이 있음
- 또한 메서드 이름으로 정렬 순서가 정해지므로 상황에 따라 정렬 순서 변경 불가
- 이럴 때 Sort 타입을 사용
- 스프링 데이터 JPA는 파라미터로 전달받은 Sort를 사용해서 알맞게 정렬 쿼리를 생성

## 페이징 처리하기
- 스프링 데이터 JPA는 페이징 처리를 위해 Pageable 타입을 이용
  - Sort 타입과 마찬가지로 find 메서드에 Pageable 타입 파라미터를 사용하면 페이징을 자동으로 처리해줌
- Pageable 타입은 인터페이스로 실제 Pageable 타입 객체는 PageRequest 클래스를 이용해서 생성 → PageRequest#of()
  - PageRequest와 Sort를 사용하면 정렬 순서를 지정할 수 있음
- Page 타입을 사용하면 데이터 목록뿐만 아니라 조건에 해당하는 전체 개수도 구할 수 있음
  - Pageable을 사용하는 메서드의 리턴 타입이 Page일 경우 스프링 데이터 JPA는 목록 조회 쿼리와 함께 COUNT 쿼리도 실행해서 조건에 해당하는 데이터 개수를 구함
  - Page는 전체 개수, 페이지 개수 등 페이징 처리에 필요한 데이터도 함께 제공

## 스펙 조합을 위한 스펙 빌더 클래스
- 스펙을 생성하다 보면 조건에 따라 스펙을 조합해야 할 때가 있음
  - if와 각 스펙을 조합하는 코드가 섞여 있다면 실수하기 좋고 복잡한 구조를 가지게 됨
  - 이 점을 보완하기 위해 필자는 스펙 빌더를 만들어 사용 (스펙 빌더 코드 → p.191)

## 동적 인스턴스 생성
- JPA는 쿼리 결과에서 임의의 객체를 동적으로 생성할 수 있는 기능을 제공
- 조회 전용 모델을 만드는 이유는 표현 영역을 통해 사용자에게 데이터를 보여주기 위함
- 동적 인스턴스의 장점
  - JPQL을 그대로 사용하므로 객체 기준으로 쿼리를 작성하면서도 동시에 지연/즉시 로딩과 같은 고민 없이 원하는 모습으로 데이터를 조회할 수 있음

## 하이버네이트 @Subselect 사용
- 하이버네이트는 JPA 확장 기능으로 @Subselect를 제공함
- @Subselect는 쿼리 결과를 @Entity로 매핑할 수 있는 유용한 기능
- @Subselect를 사용하면 쿼리 실행 결과를 매핑할 테이블처럼 사용
- 뷰를 수정할 수 없듯이 @Subselect로 조회한 @Entity 역시 수정 불가함
  - 실수로 @Subselect를 이용한 @Entity의 매핑 필드를 수정하면 하이버네이트는 변경 내역을 반영하는 update 쿼리를 실행함
  - 하지만 매핑한 테이블이 없으므로 에러 발생
  - 이런 문제를 방지하기 위해 @Immutable을 사용
  - @Immutable을 사용하면 하이버네이트는 해당 엔티티의 매핑 필더/프로퍼티가 변경되도 DB에 반영하지 않고 무시함
- @Synchronize는 해당 엔티티와 관련된 테이블 목록을 명시
  - 하이버네이트는 엔티티를 로딩하기 전에 지정한 테이블과 관련된 변경이 발생하면 플러시를 먼저 함
- @Subselect는 이름처럼 @Subselect의 값으로 지정한 쿼리를 form 절의 서브 쿼리로 사용함
  - 쿼리가 이러한 형태를 갖는다는 점을 유념해야 함
  - 서브 쿼리를 사용하고 싶지 않다면 네이티브 SQL 쿼리를 사용하거나 마이바티스와 같은 별도 매퍼를 사용해서 조회 기능을 구현해야 함