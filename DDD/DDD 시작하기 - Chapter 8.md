# 애그리거트 트랜잭션 관리
- 애그리거트의 트랜잭션
- 애그리거트 잠금 기법

## 애그리거트와 트랜잭션
- 한 애그리거트를 두 사용자가 동시에 변경할 때 트랜잭션이 필요함
- DBMS가 지원하는 트랜잭션과 함께 애그리거트를 위한 추가적인 트랜잭션 처리 기법이 필요함
- 애그리거트에 대해 사용할 수 있는 대표적인 트랜잭션 처리 방식 → 선점(비관적) 잠금, 비선점(낙관적) 잠금

## 선점 잠금
- 먼저 애그리거트를 구한 스레드가 애그리거트 사용이 끝날 때까지 다른 스레드가 해당 애그리거트를 수정하지 못하게 막는 방식
- 한 스레드가 애그리거트를 구하고 수정하는 동안 다른 스레드가 수정할 수 없으므로 동시에 애그리거트를 수정할 때 발생하는 데이터 충돌 문제를 해소할 수 있음
- 선점 잠금은 보통 DBMS가 제공하는 행단위 잠금을 사용해서 구현
- 스프링 데이터 JPA는 @Lock 애너테이션을 사용해서 잠금 모드를 지정
- 선점 잠금과 교착 상태
  - 선점 잠금 기능을 사용할 때는 잠금 순서에 따른 교착 상태가 발생하지 않도록 주의해야 함
  - 선점 잠금에 따른 교착 상태는 상대적으로 사용자 수가 많을 때 발생할 가능성이 높고, 사용자 수가 많아지면 교착 상태에 빠지는 스레드는 더 빠르게 증가함
    - 더 많은 스레드가 교착 상태에 빠질수록 시스템은 아무것도 할 수 없는 상태가 됨
  - 이런 문제가 발생하지 않도록 하려면 잠금을 구할 때 최대 대기 시간을 지정해야 함
    - JPA의 'javax.persistence.lock.timeout' 힌트 사용
    - 지정한 시간 이내에 잠금을 구하지 못하면 익셉션을 발생시킴 (DBMS에 따라 힌트가 적용되지 않을 수 있음)
    - 스프링 데이터 JPA는 @QueryHints 애너테이션을 사용해서 쿼리 힌트 지정 가능

## 비선점 잠금
- 선점 잠금으로 모든 트랜잭션 충돌 문제가 해결되는 것은 아님
- 비선점 잠금은 동시에 접근하는 것을 막는 대신 변경한 데이터를 실제 DBMS에 반영하는 시점에 변경 가능 여부를 확인하는 방식
- 비선점 잠금을 구현하려면 애그리거트에 버전으로 사용할 숫자 타입 프로퍼티를 추가해야 함
- JPA는 버전을 이용한 비선점 잠금 기능을 지원
  - 버전을 사용할 필드에 @Version 애너테이션을 붙이고 매핑되는 테이블에 버전을 저장할 컬럼 추가
  - 비선점 잠금을 위한 쿼리를 실행할 때 쿼리 실행 결과로 수정된 행의 개수가 0이면 이미 누군가 앞서 데이터를 수정한 것
    - 트랜잭션이 충돌한 것이므로 트랜잭션 종료 시점에 익셉션이 발생 (OptimisticLockingFailureException)
    - 표현 영역 코드는 이 익셉션이 발생했는지에 따라 트랜잭션 충돌이 일어났는지 확인할 수 있음
- 강제 버전 증가
  - 애그리거트 내에 어떤 구성요소의 상태가 바뀌면 루트 애그리거트의 버전값이 증가해야 비선점 잠금이 올바르게 동작함
    - JPA는 이런 문제를 처리할 수 있도록 EntityManager#find() 메서드로 엔티티를 구할 때 강제로 버전 값을 증가시키는 잠금 모드를 지원
      - LockModeType.OPTIMISTIC_FORCE_INCREMENT → 해당 엔티티의 상태가 변경되었는지에 상관없이 트랜잭션 종료 시점에 버전 값 증가 처리
      - 이 잠금 모드를 사용하면 애그리거트 루트 엔티티가 아닌 다른 엔티티나 밸류가 변경되더라도 버전 값을 증가시킬 수 있으므로 비선점 잠금 기능을 안전하게 적용할 수 있음
      - 스프링 데이터 JPA를 사용하면 @Lock 애너테이션을 이용해 지정 

## 오프라인 선점 잠금
- 단일 트랜잭션에서 동시 변경을 막는 선점 잠금 방식과 달리 오프라인 선점 잠금은 여러 트랜잭션에 걸쳐 동시 변경을 막음
  - 첫 번째 트랜잭션을 시작할 때 오프라인 잠금을 선점하고, 마지막 트랜잭션에서 잠금을 해제
  - 잠금을 해제하기 전까지 다른 사용자는 잠금을 구할 수 없음
  - 오프라인 선점 방식은 잠금 유효 시간을 가져야 함
- 오프라인 선점 잠금을 위한 LockManager 인터페이스와 관련 클래스
  - 오프라인 선점 잠금은 크게 잠금 선점 시도, 잠금 확인, 잠금 해제, 잠금 유효시간 연장의 네 가지 기능이 필요함
    - 이 기능을 위한 LockManager 인터페이스
  - 잠금을 선점한 이후에 실행하는 기능은 다음과 같은 상황을 고려하여 반드시 주어진 LockId를 갖는 잠금이 유효한지 확인해야 함
    - 잠금 유효 시간이 지났으면 이미 다른 사용자가 잠금을 선점
    - 잠금을 선점하지 않은 사용자가 기능을 실행했다면 기능 실행을 막아야 함
- DB를 이용한 LockManager 구현
  - (테이블) Locks → (컬럼) type, id, lockid, expiration_time